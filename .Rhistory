# Note: This code chunk is not run here, but it is called and run at the start of every subsequent section. Any changes made here will be duplicated throughout the rest of the document.
set.seed(1)
num_reps = 1000
all_Ns = c(100, 200, 500, 1000, 2000, 5000, 10000)
p_conf = 3  # Number of confounders
# Regression coefficients
## Intercepts are set separately for each model so that the mean of the linear predictor is approximately zero
## M model
a_1 = 1                       # Coefficient for X
A_2 = rep(1, times = p_conf)  # Coefficients for confounders
# Y model
b_1 = 1                       # Coefficient for M
b_2 = 1                       # Coefficient for X
B_3 = rep(1, times = p_conf)  # Coefficients for confounders
# Containers for output
all_a_hats = list()
all_b_hats = list()
all_a_SEs = list()
all_b_SEs = list()
all_med_hats = list()
all_med_SEs = list()
# Values of X and W for which we compute the total effect
x_pred = 0
W_pred = c(1,1,1)
# Values of a_0 and b_0
a_0 = 0
b_0 = -0.5
n = 10000
n = 1000
i=1
# Containers for output with this value of n
some_a_hats = list()
some_b_hats = list()
some_a_SEs = list()
some_b_SEs = list()
some_med_hats = list()
some_med_SEs = list()
# Generate data
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
mean(M)
sd(M)
mean(Y)
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
a_hat
a_cov
M_data
head(M_data)
summary(M_model)
Y
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
# Estimate mediation effect
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
eta_hat
zeta_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
some_med_hats[[i]] = med_hat
med_hat
eta_hat
a_x
zeta_hat
b_x
b_m
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat)
med_hat
eta_hat
a_x_hat
zeta_hat
b_x_hat
b_m_hat
med_hat
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
joint_cov
det(joint_cov)
det(joint_cov)*n
n
det(joint_cov)*n^(a_length + b_length)
det(joint_cov)*n^((a_length + b_length)/2)
log(det(joint_cov))
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
norm(grad_med)
?norm
norm(as.vector(grad_med))
grad_med
str(grad_med)
unlist(grad_med)
matrix(grad_med)
norm(matrix(grad_med))
norm(matrix(grad_med), "2")
## Apply delta-method
asymp_reg_cov = n * joint_cov
asymp_reg_cov
log(det(asymp_reg_cov))
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_var
med_asymp_SE = sqrt(med_asymp_var)
med_asymp_SE
med_SE = med_asymp_SE / sqrt(n)
med_SE
library(mediate)
library(mediation)
data("student")
student
library(lme4)
med.fit <- glmer(attachment ~ catholic + gender + income + pared + (1 | SCH_ID), family = binomial(link = "logit"), data = student)
out.fit <- glmer(fight ~ catholic * attachment + gender + income + pared + (1 + attachment | SCH_ID), family = binomial(link = "logit"), data = student)
set.seed(1)
med.out <- mediate(med.fit, out.fit, treat = "catholic", mediator = "attachment", sims = 100)
summary(med.out)
med.out <- mediate(med.fit, out.fit, treat = "catholic", mediator = "attachment", sims = 1000)
summary(med.out)
summary(med.out, output="bygroup")
table(student$SCH_ID)
library(dplyr)
student_small = filter(student, SCH_ID < 100)
med.fit <- glmer(attachment ~ catholic + gender + income + pared + (1 | SCH_ID), family = binomial(link = "logit"), data = student_small)
out.fit <- glmer(fight ~ catholic * attachment + gender + income + pared + (1 + attachment | SCH_ID), family = binomial(link = "logit"), data = student_small)
med.out <- mediate(med.fit, out.fit, treat = "catholic", mediator = "attachment", sims = 1000)
med.out <- mediate(med.fit, out.fit, treat = "catholic", mediator = "attachment", sims = 500)
summary(med.out)
summary(med.out, output="bygroup")
summary(med.out)
ranef(med.fit)
vcov(med.fit)
q = vector("list", med.fit.ranef)
q = vector("list", ranef(med.fit))
ranef(med.fit)
vector(ranef(med.fit))
vector("list", ranef(med.fit))
ranef(med.fit)
head(ranef(med.fit))
se.ranef.new(med.fit)
?lme4::ranef
ranef(med.fit, condVar = TRUE)
ranef(med.fit, condVar = FALSE)
ranef(med.fit, condVar = TRUE)
attr(ranef(med.fit, condVar = TRUE), "postVar")
attr(ranef(med.fit, condVar = TRUE)[[1]], "postVar")
ranef(med.fit, condVar = FALSE)
med.fit <- glmer(attachment ~ catholic + gender + income + pared + (1 + catholic | SCH_ID), family = binomial(link = "logit"), data = student_small)
vector("list", ranef(med.fit))
se.ranef.new(med.fit)
ranef(med.fit, condVar = FALSE)
attr(ranef(med.fit, condVar = TRUE)[[1]], "postVar")
ranef(med.fit, condVar = FALSE)
# Force text wrapping for long lines
library(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
library(kableExtra)
knitr::opts_chunk$set(echo = TRUE)
# Random effects covariances
a_RE_sds
# , cached=TRUE}
# Note: This code chunk is not run here, but it is called and run at the start of every subsequent section. Any changes made here will be duplicated throughout the rest of the document.
set.seed(1)
num_reps = 1000
all_Ns = c(100, 200, 500, 1000, 2000, 5000, 10000)
p_conf = 3  # Number of confounders
# Regression coefficients
## Intercepts are set separately for each model so that the mean of the linear predictor is approximately zero
## M model
a_1 = 1                       # Coefficient for X
A_2 = rep(1, times = p_conf)  # Coefficients for confounders
# Y model
b_1 = 1                       # Coefficient for M
b_2 = 1                       # Coefficient for X
B_3 = rep(1, times = p_conf)  # Coefficients for confounders
# Containers for output
all_a_hats = list()
all_b_hats = list()
all_a_SEs = list()
all_b_SEs = list()
all_med_hats = list()
all_med_SEs = list()
# , cached=TRUE}
# Note: This code chunk is not run here, but it is called and run at the start of every subsequent section. Any changes made here will be duplicated throughout the rest of the document.
set.seed(1)
num_reps = 1000
all_Ns = c(100, 200, 500, 1000, 2000, 5000, 10000)
p_conf = 3  # Number of confounders
# Regression coefficients
## Intercepts are set separately for each model so that the mean of the linear predictor is approximately zero
## M model
a_1 = 1                       # Coefficient for X
A_2 = rep(1, times = p_conf)  # Coefficients for confounders
# Y model
b_1 = 1                       # Coefficient for M
b_2 = 1                       # Coefficient for X
B_3 = rep(1, times = p_conf)  # Coefficients for confounders
# Containers for output
all_a_hats = list()
all_b_hats = list()
all_a_SEs = list()
all_b_SEs = list()
all_med_hats = list()
all_med_SEs = list()
# Force text wrapping for long lines
library(formatR)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
library(kableExtra)
knitr::opts_chunk$set(echo = TRUE)
source("../src/Helpers.R")
library(lme4)     # For fitting GLMMs using glmer()
library(MASS)     # For simulating multivariate normals using mvrnorm()
library(merDeriv) # For computing the full information matrix from models fit using lme4
# Fixed effects for intercepts
a_0 = 0
b_0 = -0.5
# Random effects
sigma_a_0 = 0.2
sigma_a_1 = 0.2 * abs(a_1)
cor_a0_a1 = 0.2
cov_a0_a1 = sigma_a_0 * sigma_a_1 * cor_a0_a1
Sigma_a = matrix(c(sigma_a_0^2, cov_a0_a1, cov_a0_a1, sigma_a_1^2), nrow = 2, ncol = 2)
sigma_b_0 = 0.2 * abs(b_0)
sigma_b_1 = 0.2 * abs(b_1)
cor_b0_b1 = 0.2
cov_b0_b1 = sigma_b_0 * sigma_b_1 * cor_b0_b1
Sigma_b = matrix(c(sigma_b_0^2, cov_b0_b1, cov_b0_b1, sigma_b_1^2), nrow = 2, ncol = 2)
# Number of clusters
K=5
n = all_Ns[2]
# n = all_Ns[1]
all_Xs = list()
all_Ws = list()
for(k in 1:K){
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
all_Xs[[k]] = X
all_Ws[[k]] = W
}
# Generate M
all_Ms = list()
for(k in 1:K){
eta_vec_fixed = a_0 + a_1*all_Xs[[k]] + all_Ws[[k]]%*%A_2
## Add random effects
a_ran = mvrnorm(1, mu = rep(0, 2), Sigma = Sigma_a)
eta_vec = eta_vec_fixed + a_ran[1] + a_ran[2]*all_Xs[[k]]
## Generate M
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
all_Ms[[k]] = M
}
# Generate Y
all_Ys = list()
for(k in 1:K){
zeta_vec_fixed = b_0 + b_1*all_Ms[[k]] + b_2 * all_Xs[[k]] + all_Ws[[k]]%*%B_3
## Add random effects
b_ran = mvrnorm(1, mu = rep(0, 2), Sigma = Sigma_b)
zeta_vec = zeta_vec_fixed + b_ran[1] + b_ran[2]*all_Xs[[k]]
## Generate Y
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
all_Ys[[k]] = Y
}
# Consolidate groups
X = do.call(c, all_Xs)
W = do.call(rbind, all_Ws)
M = do.call(c, all_Ms)
Y = do.call(c, all_Ys)
group = rep(1:K, each = n)
M_data = data.frame(M, X, W1 = W[, 1], W2 = W[, 2], W3 = W[,3], group = group)
M_model = glmer(M ~ X + W1 + W2 + W3 + (1 + X | group), data = M_data, family = binomial(link = "logit"))
M_model_info = attributes(VarCorr(M_model)$group)
a_hat = fixef(M_model)
a_RE_sds = M_model_info$stddev
a_RE_cor = M_model_info$correlation[2,1]
a_cov = vcov(M_model, full=TRUE, ranpar="sd")
# a_hat = summary(M_model)$coefficients[, 1]
# a_SE = summary(M_model)$coefficients[, 2]
# a_cov = vcov(M_model)
Y_data = data.frame(Y, M, X, W1 = W[, 1], W2 = W[, 2], W3 = W[,3], group = group)
Y_model = glmer(Y ~ M + X + W1 + W2 + W3 + (1 + X | group), data = Y_data, family = binomial(link = "logit"))
Y_model_info = attributes(VarCorr(Y_model)$group)
b_hat = fixef(Y_model)
b_RE_sds = Y_model_info$stddev
b_RE_cor = Y_model_info$correlation[2,1]
b_cov = vcov(Y_model, full=TRUE, ranpar="sd")
# b_hat = summary(Y_model)$coefficients[, 1]
# b_SE = summary(Y_model)$coefficients[, 2]
# b_cov = vcov(Y_model)
# Fixed-effects
x_pred = 0
W_pred = c(1,1,1)
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:5]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:6]
# Linear predictors
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
eta_hat
zeta_hat
a_RE_sds
# Random effects covariances
s_M_0 = a_RE_sds[1]
s_M_x = a_RE_sds[2]
rho_m = a_RE_cor
s_Y_0 = b_RE_sds[1]
s_Y_x = b_RE_sds[2]
rho_y = b_RE_cor
sigma_u = function(x, s_0, s_x, rho){
return(sqrt(s_0^2 + s_x^2 + 2*rho*s_0*s_x*x + s_x^2*x^2))
}
sigma_fun = function(x, s_0, s_x, rho){
A = s_0^2
B = 2 * x * rho * s_0 * s_x
C = x^2 * s_x^2
return(sqrt(A + B + C))
}
# Random effects covariances
s_M_0 = a_RE_sds[1]
s_M_x = a_RE_sds[2]
rho_m = a_RE_cor
s_Y_0 = b_RE_sds[1]
s_Y_x = b_RE_sds[2]
rho_y = b_RE_cor
# Sigma functions
sigma_M1 = sigma_fun(x_pred, s_M_0, s_M_x, rho_m)
sigma_M2 = sigma_fun(x_pred + 1, s_M_x, s_M_0, rho_m)
sigma_Y1 = sigma_fun(x_pred, s_Y_0, s_Y_x, rho_y)
sigma_Y2 = sigma_fun(x_pred + 1, s_Y_x, s_Y_0, rho_y)
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = Phi(eta_hat, zeta_hat, a_x_hat, b_m_hat, b_x_hat, sigma_M2, sigma_Y2, sigma_M1, sigma_Y1)
eta_hat
zeta_hat
a_x_hat
b_m_hat
b_x_hat
sigma_M2
sigma_Y2
# Linear predictors
eta_hat = unlist(a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat)
eta_hat
# Linear predictors
eta_hat = numeric(a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat)
eta_hat
# Linear predictors
eta_hat = as.numeric(a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat)
eta_hat
zeta_hat = as.numeric(b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat)
zeta_hat
# Linear predictors
eta_hat = as.numeric(a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat)
zeta_hat = as.numeric(b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat)
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = Phi(eta_hat, zeta_hat, a_x_hat, b_m_hat, b_x_hat, sigma_M2, sigma_Y2, sigma_M1, sigma_Y1)
med_hat
## Computes the sigma function, e.g., sigma_u(x)
sigma_fun = function(x, s_0, s_x, rho){
A = s_0^2
B = 2 * x * rho * s_0 * s_x
C = x^2 * s_x^2
return(sqrt(A + B + C))
}
## Partial derivatives of sigma_fun
d_sigma_d_s0 = function(x, s_0, s_x, rho){
return((s_0 + x * rho * s_x) / sigma_fun(x, s_0, s_x, rho))
}
x = 1
s_0 = 2
s_x = 3
rho = 4
(sigma_fun(x, s_0 + e, s_x, rho) - sigma_fun(x, s_0, s_x, rho)) / e
x = 1
s_0 = 2
s_x = 3
rho = 4
e = 0.000001
(sigma_fun(x, s_0 + e, s_x, rho) - sigma_fun(x, s_0, s_x, rho)) / e
d_sigma_d_s0(x, s_0, s_x, rho)
d_sigma_d_sx = function(x, s_0, s_x, rho){
return((s_x * x^2 + x * rho * s_0) / sigma_fun(x, s_0, s_x, rho))
}
(sigma_fun(x, s_0, s_x + e, rho) - sigma_fun(x, s_0, s_x, rho)) / e
d_sigma_d_sx(x, s_0, s_x, rho)
d_sigma_d_rho = function(x, s_0, s_x, rho){
return((s_0 * s_x * x) / sigma_fun(x, s_0, s_x, rho))
}
(sigma_fun(x, s_0, s_x, rho + e) - sigma_fun(x, s_0, s_x, rho)) / e
d_sigma_d_rho(x, s_0, s_x, rho)
a_hat
a_hat[3:end]
a_hat[-c(1,2)]
W
W_pred
x
W
w = W_pred
W = W_pred
a
a = a_hat
a
b = b_hat
theta = c(s_M_0, s_M_x, rho_M)
rho_M = a_RE_cor
rho_M = a_RE_cor
s_Y_0 = b_RE_sds[1]
rho_Y = b_RE_cor
theta = c(s_M_0, s_M_x, rho_M)
gamma = c(s_Y_0, s_Y_x, rho_Y)
grad_eta = function(a, theta, b, gamma, x, W){
q_M = length(theta)
q_Y = length(gamma)
len_W = length(W)
output = c(1,
x,
W,
rep(0, times=q_M),   # RE pars for M
rep(0, times=3 + q_W),  # Fixed effects for Y
rep(0, times = q_Y))  # RE pars for Y
}
q_M = length(theta)
q_Y = length(gamma)
len_W = length(W)
output = c(1,
x,
W,
rep(0, times=q_M),   # RE pars for M
rep(0, times=3 + q_W),  # Fixed effects for Y
rep(0, times = q_Y))  # RE pars for Y
len_W = length(W)
output = c(1,
x,
W,
rep(0, times=q_M),   # RE pars for M
rep(0, times=3 + len_W),  # Fixed effects for Y
rep(0, times = q_Y))  # RE pars for Y
output
q_M = length(theta)
q_Y = length(gamma)
len_W = length(W)
output = c(rep(0, times=2 + len_W),  # a_0, a_x, A_2
rep(0, times = q_M),   # theta
1,  # beta_0
0,  # beta_M
x,  # beta_X
W,  # beta_3
rep(0, times = q_Y))  # gamma
output
q_M = length(theta)
q_Y = length(gamma)
len_W = length(W)
output = c(rep(0, times=2 + len_W),  # a_0, a_x, A_2
rep(0, times = q_M),   # theta
0, # b_0
1, # b_m
0, # b_x
rep(0, times = len_W),  # B_3
rep(0, times = q_Y))  # gamma
output
x = 2
W = c(3, 4, 5)
s_0 = theta[1]
s_x = theta[2]
phi = theta[3]
