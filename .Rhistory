W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
M
Y
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficienjts[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
W_pred
B_3_hat
b_hat
Y_model
summary(Y_model)$coefficienjts[,1]
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
B_3_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
## Apply delta-method
asymp_reg_cov = n * joint_cov
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_SE = sqrt(med_asymp_var)
med_SE = med_asymp_SE / sqrt(n)
some_med_SEs[[i]] = med_SE
med_SE
# Note: This code chunk is not run here, but it is called and run at the start of every subsequent section. Any changes made here will be duplicated throughout the rest of the document.
set.seed(1)
num_reps = 1000
all_Ns = c(100, 200, 500, 1000, 2000, 5000, 10000)
p_conf = 3  # Number of confounders
# Regression coefficients
## Intercepts are set separately for each model so that the mean of the linear predictor is approximately zero
## M model
a_1 = 1                       # Coefficient for X
A_2 = rep(1, times = p_conf)  # Coefficients for confounders
# Y model
b_1 = 1                       # Coefficient for M
b_2 = 1                       # Coefficient for X
B_3 = rep(1, times = p_conf)  # Coefficients for confounders
# Containers for output
all_a_hats = list()
all_b_hats = list()
all_a_SEs = list()
all_b_SEs = list()
all_med_hats = list()
all_med_SEs = list()
for(j in seq_along(all_Ns)){
n = all_Ns[j]
# Containers for output with this value of n
some_a_hats = list()
some_b_hats = list()
some_a_SEs = list()
some_b_SEs = list()
some_med_hats = list()
some_med_SEs = list()
for(i in 1:num_reps){
# Generate data
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
# Fit models
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
# Estimate mediation effect
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
# Estimate SE
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
## Apply delta-method
asymp_reg_cov = n * joint_cov
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_SE = sqrt(med_asymp_var)
med_SE = med_asymp_SE / sqrt(n)
some_med_SEs[[i]] = med_SE
}
# Store output for current value of n
all_a_hats[[j]] = some_a_hats
all_b_hats[[j]] = some_b_hats
all_a_SEs[[j]] = some_a_SEs
all_b_SEs[[j]] = some_b_SEs
all_med_hats[[j]] = some_med_hats
all_med_SEs[[j]] = some_med_SEs
}
all_a_hats
all_a_hats
all_b_hats
# Re-format output to be more useful.
data_med_hats = lapply(all_med_hats, unlist)
data_med_SEs = lapply(all_med_SEs, unlist)
# SD of estimates across Monte Carlo samples
emp_SEs = sapply(data_med_hats, sd)
emp_SEs
data_med_hats
all_med_hats
some_med_hats
for(j in seq_along(all_Ns)){
n = all_Ns[j]
# Containers for output with this value of n
some_a_hats = list()
some_b_hats = list()
some_a_SEs = list()
some_b_SEs = list()
some_med_hats = list()
some_med_SEs = list()
for(i in 1:num_reps){
# Generate data
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
# Fit models
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
# Estimate mediation effect
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
some_hed_hats[[i]] = med_hat
# Estimate SE
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
## Apply delta-method
asymp_reg_cov = n * joint_cov
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_SE = sqrt(med_asymp_var)
med_SE = med_asymp_SE / sqrt(n)
some_med_SEs[[i]] = med_SE
}
# Store output for current value of n
all_a_hats[[j]] = some_a_hats
all_b_hats[[j]] = some_b_hats
all_a_SEs[[j]] = some_a_SEs
all_b_SEs[[j]] = some_b_SEs
all_med_hats[[j]] = some_med_hats
all_med_SEs[[j]] = some_med_SEs
}
for(j in seq_along(all_Ns)){
n = all_Ns[j]
# Containers for output with this value of n
some_a_hats = list()
some_b_hats = list()
some_a_SEs = list()
some_b_SEs = list()
some_med_hats = list()
some_med_SEs = list()
for(i in 1:num_reps){
# Generate data
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
# Fit models
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
# Estimate mediation effect
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
some_med_hats[[i]] = med_hat
# Estimate SE
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
## Apply delta-method
asymp_reg_cov = n * joint_cov
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_SE = sqrt(med_asymp_var)
med_SE = med_asymp_SE / sqrt(n)
some_med_SEs[[i]] = med_SE
}
# Store output for current value of n
all_a_hats[[j]] = some_a_hats
all_b_hats[[j]] = some_b_hats
all_a_SEs[[j]] = some_a_SEs
all_b_SEs[[j]] = some_b_SEs
all_med_hats[[j]] = some_med_hats
all_med_SEs[[j]] = some_med_SEs
}
# Re-format output to be more useful.
data_med_hats = lapply(all_med_hats, unlist)
data_med_SEs = lapply(all_med_SEs, unlist)
data_med_hats
str(all_med_hats)
data_med_SEs = lapply(all_med_SEs, unlist)
# SD of estimates across Monte Carlo samples
emp_SEs = sapply(data_med_hats, sd)
emp_SEs
# Summaries of estimated SEs (mean and median)
mean_delta_SEs = sapply(data_med_SEs, mean)
median_delta_SEs = sapply(data_med_SEs, median)
# Combine into a table
results = data.frame(n = all_Ns, Empirical = emp_SEs,
Mean = mean_delta_SEs, Median = median_delta_SEs,
"Percent_Err_Mean" = 100*(mean_delta_SEs - emp_SEs)/emp_SEs,
"Percent_Err_Median" = 100*(median_delta_SEs - emp_SEs)/emp_SEs)
results
# Note: This code chunk is not run here, but it is called and run at the start of every subsequent section. Any changes made here will be duplicated throughout the rest of the document.
set.seed(1)
num_reps = 1000
all_Ns = c(100, 200, 500, 1000, 2000, 5000, 10000)
p_conf = 3  # Number of confounders
# Regression coefficients
## Intercepts are set separately for each model so that the mean of the linear predictor is approximately zero
## M model
a_1 = 1                       # Coefficient for X
A_2 = rep(1, times = p_conf)  # Coefficients for confounders
# Y model
b_1 = 1                       # Coefficient for M
b_2 = 1                       # Coefficient for X
B_3 = rep(1, times = p_conf)  # Coefficients for confounders
# Containers for output
all_a_hats = list()
all_b_hats = list()
all_a_SEs = list()
all_b_SEs = list()
all_med_hats = list()
all_med_SEs = list()
# Values of X and W for which we compute the total effect
x_pred = 0
W_pred = c(1,1,1)
# Values of a_0 and b_0
a_0 = 0
b_0 = -0.5
n = 10000
n = 1000
i=1
# Containers for output with this value of n
some_a_hats = list()
some_b_hats = list()
some_a_SEs = list()
some_b_SEs = list()
some_med_hats = list()
some_med_SEs = list()
# Generate data
X = rnorm(n, mean=0, sd=1)
W = matrix(rnorm(n*p_conf, mean=0, sd=1), nrow = n, ncol = p_conf)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
## Generate M
eta_vec = a_0 + a_1*X + W%*%A_2
p_M_vec = expit(eta_vec)
M = rbinom(n, size = 1, prob = p_M_vec)
## Generate Y
zeta_vec = b_0 + b_1*M + b_2*X + W%*%B_3
p_Y_vec = expit(zeta_vec)
Y = rbinom(n, size = 1, prob = p_Y_vec)
mean(M)
sd(M)
mean(Y)
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
a_hat
a_cov
M_data
head(M_data)
summary(M_model)
Y
## M
M_data = data.frame(M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
M_model = glm(M ~ X + W1 + W2 + W3, data = M_data, family = binomial(link = "logit"))
a_hat = summary(M_model)$coefficients[,1]
a_SE = summary(M_model)$coefficients[,2]
a_cov = vcov(M_model)
some_a_hats[[i]] = a_hat
some_a_SEs[[i]] = a_SE
## Y
Y_data = data.frame(Y, M, X, W1 = W[,1], W2 = W[,2], W3 = W[,3])
Y_model = glm(Y ~ M + X + W1 + W2 + W3, data = Y_data, family = binomial(link = "logit"))
b_hat = summary(Y_model)$coefficients[,1]
b_SE = summary(Y_model)$coefficients[,2]
b_cov = vcov(Y_model)
some_b_hats[[i]] = b_hat
some_b_SEs[[i]] = b_SE
# Estimate mediation effect
## Extract coefficients
a_0_hat = a_hat[1]
a_x_hat = a_hat[2]
A_2_hat = a_hat[3:length(a_hat)]
b_0_hat = b_hat[1]
b_m_hat = b_hat[2]
b_x_hat = b_hat[3]
B_3_hat = b_hat[4:length(b_hat)]
## Linear predictor for M
eta_hat = a_0_hat + a_x_hat*x_pred + W_pred%*%A_2_hat
zeta_hat = b_0_hat + b_x_hat * x_pred + W_pred %*% B_3_hat
eta_hat
zeta_hat
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x, zeta_hat, b_x, b_m)
some_med_hats[[i]] = med_hat
med_hat
eta_hat
a_x
zeta_hat
b_x
b_m
# Mediation effect
## See Helpers.R for the function get_odds_ratio
med_hat = get_odds_ratio(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat)
med_hat
eta_hat
a_x_hat
zeta_hat
b_x_hat
b_m_hat
med_hat
## Build joint covariance matrix
a_length = nrow(a_cov)
b_length = nrow(b_cov)
joint_cov = matrix(0, nrow = a_length + b_length, ncol = a_length + b_length)
joint_cov[1:a_length, 1:a_length] = a_cov
joint_cov[(a_length+1):(a_length+b_length), (a_length+1):(a_length+b_length)] = b_cov
joint_cov
det(joint_cov)
det(joint_cov)*n
n
det(joint_cov)*n^(a_length + b_length)
det(joint_cov)*n^((a_length + b_length)/2)
log(det(joint_cov))
## Compute gradient of mediation effect
grad_med = d_OR_d_theta(eta_hat, a_x_hat, zeta_hat, b_x_hat, b_m_hat, x_pred, W_pred)
norm(grad_med)
?norm
norm(as.vector(grad_med))
grad_med
str(grad_med)
unlist(grad_med)
matrix(grad_med)
norm(matrix(grad_med))
norm(matrix(grad_med), "2")
## Apply delta-method
asymp_reg_cov = n * joint_cov
asymp_reg_cov
log(det(asymp_reg_cov))
med_asymp_var = grad_med %*% asymp_reg_cov %*% grad_med
med_asymp_var
med_asymp_SE = sqrt(med_asymp_var)
med_asymp_SE
med_SE = med_asymp_SE / sqrt(n)
med_SE
